var documenterSearchIndex = {"docs":
[{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/MNIST.jl\"","category":"page"},{"location":"literate/MNIST/#MNIST","page":"MNIST","title":"MNIST","text":"","category":"section"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"We begin by importing the required packages. We load MNIST via the MLDatasets.jl package.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"import Makie\nimport CairoMakie\nimport MLDatasets\nusing Statistics: mean, std, var\nusing Random: bitrand\nusing ValueHistories: MVHistory, @trace\nusing RestrictedBoltzmannMachines: BinaryRBM, sample_from_inputs,\n    initialize!, log_pseudolikelihood, pcd!, free_energy, sample_v_from_v\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Useful function to plot grids of MNIST digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"\"\"\"\n    imggrid(A)\n\nGiven a four dimensional tensor `A` of size `(width, height, ncols, nrows)`\ncontaining `width x height` images in a grid of `nrows x ncols`, this returns\na matrix of size `(width * ncols, height * nrows)`, that can be plotted in a heatmap\nto display all images.\n\"\"\"\nimggrid(A::AbstractArray{<:Any,4}) =\n    reshape(permutedims(A, (1,3,2,4)), size(A,1)*size(A,3), size(A,2)*size(A,4))","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Load the MNIST dataset. We will train an RBM with binary (0,1) visible and hidden units. Therefore we binarize the data. In addition, we consider only one kind of digit so that training is faster.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Float = Float32\ntrain_x = MLDatasets.MNIST(split=:train)[:].features\ntrain_y = MLDatasets.MNIST(split=:train)[:].targets\ntrain_x = Array{Float}(train_x[:, :, train_y .== 0] .≥ 0.5)\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Let's visualize some random digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nrows, ncols = 10, 15\nfig = Makie.Figure(resolution=(40ncols, 40nrows))\nax = Makie.Axis(fig[1,1], yreversed=true)\nidx = rand(1:size(train_x,3), nrows * ncols) # random indices of digits\ndigits = reshape(train_x[:,:,idx], 28, 28, ncols, nrows)\nMakie.image!(ax, imggrid(digits), colorrange=(1,0))\nMakie.hidedecorations!(ax)\nMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Initialize an RBM with 400 hidden units.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"rbm = BinaryRBM(Float, (28,28), 400)\ninitialize!(rbm, train_x) # match single-site statistics\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Initially, the RBM assigns a poor pseudolikelihood to the data.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"println(\"log(PL) = \", mean(@time log_pseudolikelihood(rbm, train_x)))","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Now we train the RBM on the data.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"batchsize = 256\niters = 10000\nhistory = MVHistory()\n@time pcd!(\n    rbm, train_x; iters, batchsize,\n    callback = function(; iter, _...)\n        if iszero(iter % 100)\n            lpl = mean(log_pseudolikelihood(rbm, train_x))\n            @trace history iter lpl\n        end\n    end\n)\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"After training, the pseudolikelihood score of the data improves significantly. Plot of log-pseudolikelihood of trian data during learning.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(500,300))\nax = Makie.Axis(fig[1,1], xlabel = \"train time\", ylabel=\"pseudolikelihood\")\nMakie.lines!(ax, get(history, :lpl)...)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Sample digits from the RBM starting from a random condition.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"nsteps = 3000\nfantasy_F = zeros(nrows*ncols, nsteps)\nfantasy_x = bitrand(28,28,nrows*ncols)\nfantasy_F[:,1] .= free_energy(rbm, fantasy_x)\n@time for t in 2:nsteps\n    fantasy_x .= sample_v_from_v(rbm, fantasy_x)\n    fantasy_F[:,t] .= free_energy(rbm, fantasy_x)\nend\nnothing #hide","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Check equilibration of sampling","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(400,300))\nax = Makie.Axis(fig[1,1], xlabel=\"sampling time\", ylabel=\"free energy\")\nfantasy_F_μ = vec(mean(fantasy_F; dims=1))\nfantasy_F_σ = vec(std(fantasy_F; dims=1))\nMakie.band!(ax, 1:nsteps, fantasy_F_μ - fantasy_F_σ/2, fantasy_F_μ + fantasy_F_σ/2)\nMakie.lines!(ax, 1:nsteps, fantasy_F_μ)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"Plot the sampled digits.","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"fig = Makie.Figure(resolution=(40ncols, 40nrows))\nax = Makie.Axis(fig[1,1], yreversed=true)\nMakie.image!(ax, imggrid(reshape(fantasy_x, 28, 28, ncols, nrows)), colorrange=(1,0))\nMakie.hidedecorations!(ax)\nMakie.hidespines!(ax)\nfig","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"","category":"page"},{"location":"literate/MNIST/","page":"MNIST","title":"MNIST","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/layers/Gaussian.jl\"","category":"page"},{"location":"literate/layers/Gaussian/#Gaussian-layer","page":"Gaussian","title":"Gaussian layer","text":"","category":"section"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"In the following example we look at what the Gaussian layer hidden units look like, for different parameter values.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"First load some packages.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"import RestrictedBoltzmannMachines as RBMs\nusing CairoMakie, Statistics\nnothing #hide","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"Now initialize our Gaussian layer, with unit parameters spanning an interesting range.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"θs = [-5; 5]\nγs = [1; 2]\nlayer = RBMs.Gaussian(; θ=[θ for θ in θs, γ in γs], γ=[γ for θ in θs, γ in γs])\nnothing #hide","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"Now we sample our layer to collect some data.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"data = RBMs.sample_from_inputs(layer, zeros(size(layer)..., 10^6))\nnothing #hide","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"Let's plot the resulting histogram of the activations of each unit. We also overlay the analytical PDF.","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"fig = Figure(resolution=(700,500))\nax = Axis(fig[1,1])\nxs = repeat(reshape(range(minimum(data), maximum(data), 100), 1, 1, 100), size(layer)...)\nps = exp.(-RBMs.cgfs(layer) .- RBMs.energies(layer, xs))\nfor (iθ, θ) in enumerate(θs), (iγ, γ) in enumerate(γs)\n    hist!(ax, data[iθ, iγ, :], normalization=:pdf, label=\"θ=$θ, γ=$γ\")\n    lines!(xs[iθ, iγ, :], ps[iθ, iγ, :], linewidth=2)\nend\naxislegend(ax)\nfig","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"","category":"page"},{"location":"literate/layers/Gaussian/","page":"Gaussian","title":"Gaussian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/layers/dReLU.jl\"","category":"page"},{"location":"literate/layers/dReLU/#dReLU-layer","page":"dReLU","title":"dReLU layer","text":"","category":"section"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"In this example we look at what the dReLU layer hidden units look like, for different parameter values.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"First load some packages.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"import RestrictedBoltzmannMachines as RBMs\nimport Makie\nimport CairoMakie\nusing Statistics\nnothing #hide","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"Now initialize our dReLU layer, with unit parameters spanning an interesting range.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"θps = [-3.0; 3.0]\nθns = [-3.0; 3.0]\nγps = [0.5; 1.0]\nγns = [0.5; 1.0]\nlayer = RBMs.dReLU(;\n    θp = [θp for θp in θps, θn in θns, γp in γps, γn in γns],\n    θn = [θn for θp in θps, θn in θns, γp in γps, γn in γns],\n    γp = [γp for θp in θps, θn in θns, γp in γps, γn in γns],\n    γn = [γn for θp in θps, θn in θns, γp in γps, γn in γns]\n)\nnothing #hide","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"Now we sample our layer to collect some data.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"data = RBMs.sample_from_inputs(layer, zeros(size(layer)..., 10^6))\nnothing #hide","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"Let's plot the resulting histogram of the activations of each unit. We also overlay the analytical PDF.","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"fig = Makie.Figure(resolution=(1000, 700))\nxs = repeat(reshape(range(minimum(data), maximum(data), 100), 1,1,1,1,100), size(layer)...)\nps = exp.(-RBMs.cgfs(layer) .- RBMs.energies(layer, xs))\nfor (iθp, θp) in enumerate(θps), (iθn, θn) in enumerate(θns)\n    ax = Makie.Axis(fig[iθp,iθn], title=\"θp=$θp, θn=$θn\", xlabel=\"h\", ylabel=\"P(h)\")\n    for (iγp, γp) in enumerate(γps), (iγn, γn) in enumerate(γns)\n        Makie.hist!(ax, data[iθp, iθn, iγp, iγn, :], normalization=:pdf, bins=30, label=\"γp=$γp, γn=$γn\")\n        Makie.lines!(ax, xs[iθp, iθn, iγp, iγn, :], ps[iθp, iθn, iγp, iγn, :], linewidth=2)\n    end\n    if iθp == iθn == 1\n        Makie.axislegend(ax)\n    end\nend\nfig","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"","category":"page"},{"location":"literate/layers/dReLU/","page":"dReLU","title":"dReLU","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/metropolis.jl\"","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"import Makie\nimport CairoMakie\nusing Statistics: mean, std, var, cor\nusing Random: randn!, bitrand\nusing LogExpFunctions: logsumexp\nusing RestrictedBoltzmannMachines: BinaryRBM, energy, free_energy, metropolis!\n\nN = 5\nM = 2\nrbm = BinaryRBM(randn(N), randn(M), randn(N, M) / √N);\n\nβ = 0.5\nnsteps = 10000\nnchains = 100\nv = bitrand(N, nchains, nsteps)\nmetropolis!(v, rbm; β);\n\ncounts = Dict{BitVector, Int}()\nfor t in 1000:nsteps, n in 1:nchains\n    counts[v[:,n,t]] = get(counts, v[:,n,t], 0) + 1\nend\nfreqs = Dict(v => c / sum(values(counts)) for (v,c) in counts);\n\n𝒱 = [BitVector(digits(Bool, x; base=2, pad=N)) for x in 0:(2^N - 1)];\nℱ = free_energy.(Ref(rbm), 𝒱);\nnothing #hide","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"Commenting this until https://github.com/MakieOrg/Makie.jl/issues/2045 gets resolved. fig = Makie.Figure() ax = Makie.Axis(fig[1,1], xlabel=\"empirical freqs.\", ylabel=\"log(p)\", xscale=log10, yscale=log10) Makie.scatter!(ax, [get(freqs, v, 0.0) for v in 𝒱], exp.(-β * ℱ .- logsumexp(-β * ℱ))) Makie.scatter!(ax, [get(freqs, v, 0.0) for v in 𝒱], exp.(-ℱ .- logsumexp(-ℱ))) Makie.abline!(ax, 0, 1, color=:red) fig","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"fig = Makie.Figure()\nax = Makie.Axis(fig[1,1], xlabel=\"empirical freqs. (log)\", ylabel=\"log(p)\")\nMakie.scatter!(ax, log.([get(freqs, v, 0.0) for v in 𝒱]), -β * ℱ .- logsumexp(-β * ℱ))\nMakie.scatter!(ax, log.([get(freqs, v, 0.0) for v in 𝒱]), -ℱ .- logsumexp(-ℱ))\nMakie.abline!(ax, 0, 1, color=:red)\nfig","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"Correlation","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"cor([get(freqs, v, 0.0) for v in 𝒱], exp.(-β * ℱ .- logsumexp(-β * ℱ)))","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"","category":"page"},{"location":"literate/metropolis/","page":"Metropolis","title":"Metropolis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [RestrictedBoltzmannMachines]","category":"page"},{"location":"reference/#RestrictedBoltzmannMachines.Binary","page":"Reference","title":"RestrictedBoltzmannMachines.Binary","text":"Binary(θ)\n\nLayer with binary units, with external fields θ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.Gaussian","page":"Reference","title":"RestrictedBoltzmannMachines.Gaussian","text":"Gaussian(θ, γ)\n\nGaussian layer, with location parameters θ and scale parameters γ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.Potts","page":"Reference","title":"RestrictedBoltzmannMachines.Potts","text":"Potts(θ)\n\nLayer with Potts units, with external fields θ. Encodes categorical variables as one-hot vectors. The number of classes is the size of the first dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.RBM","page":"Reference","title":"RestrictedBoltzmannMachines.RBM","text":"RBM{V,H,W}\n\nRBM, with visible layer of type V, hidden layer of type H, and weights of type W.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.ReLU","page":"Reference","title":"RestrictedBoltzmannMachines.ReLU","text":"ReLU(θ, γ)\n\nLayer with ReLU units, with location parameters θ and scale parameters γ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.Spin","page":"Reference","title":"RestrictedBoltzmannMachines.Spin","text":"Spin(θ)\n\nLayer with spin units, with external fields θ. The energy of a layer with units s_i is given by:\n\nE = -sum_i theta_i s_i\n\nwhere each spin s_i takes values pm 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#RestrictedBoltzmannMachines.BinaryRBM-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.BinaryRBM","text":"BinaryRBM(a, b, w)\nBinaryRBM(N, M)\n\nConstruct an RBM with binary visible and hidden units, which has an energy function:\n\nE(v h) = -av - bh - vwh\n\nEquivalent to RBM(Binary(a), Binary(b), w).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.HopfieldRBM-NTuple{4, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.HopfieldRBM","text":"HopfieldRBM(g, θ, γ, w)\nHopfieldRBM(g, w)\n\nConstruct an RBM with spin visible units and Gaussian hidden units. If not given, θ = 0 and γ = 1 by default.\n\nE(v h) = -gv - θh + sum_mu fracγ_mu2 h_mu^2 - vwh\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.ais-Tuple{RestrictedBoltzmannMachines.RBM, RestrictedBoltzmannMachines.RBM, AbstractArray, AbstractVector}","page":"Reference","title":"RestrictedBoltzmannMachines.ais","text":"ais(rbm0, rbm1, v0, βs)\n\nProvided v0 is an equilibrated sample from rbm0, returns F such that mean(exp.(F)) is an unbiased estimator of Z1/Z0, the ratio of partition functions of rbm1 and rbm0.\n\n!!! tip Use logmeanexp     logmeanexp(F), using the function logmeanexp[@ref] provided in this package,     tends to give a better approximation of log(Z1) - log(Z0) than mean(F).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.aise-Tuple{RestrictedBoltzmannMachines.RBM, AbstractVector{<:Real}}","page":"Reference","title":"RestrictedBoltzmannMachines.aise","text":"aise(rbm, [βs]; [nbetas], init=rbm.visible, nsamples=1)\n\nAIS estimator of the log-partition function of rbm. It is recommended to fit init to the single-site statistics of rbm (or the data).\n\n!!! tip Use large nbetas     For more accurate estimates, use larger nbetas. It is usually better to have     large nbetas and small nsamples, rather than large nsamples and small nbetas.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.anneal-Tuple{RestrictedBoltzmannMachines.RBM, RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.anneal","text":"anneal(rbm0, rbm1; β)\n\nReturns an RBM that interpolates between rbm0 and rbm1. Denoting by E0(v, h) and E1(v, h) the energies assigned by rbm0 and rbm1, respectively, the returned RBM assigns energies given by:\n\nE(v,h) = (1 - β) * E0(v) + β * E1(v, h)\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batch_size-Tuple{Any, Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.batch_size","text":"batch_size(rbm, v, h)\n\nReturns the batch size if energy(rbm, v, h) were computed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batch_size-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batch_size","text":"batch_size(layer, x)\n\nBatch sizes of x, with respect to layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batchcov-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batchcov","text":"batchcov(layer, x; wts = nothing, [mean])\n\nCovariance of x over batch dimensions, weigthed by wts.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batchdims-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batchdims","text":"batchdims(layer, x)\n\nIndices of batch dimensions in x, with respect to layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batchmean-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batchmean","text":"batchmean(layer, x; wts = nothing)\n\nMean of x over batch dimensions, weigthed by wts.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batchstd-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batchstd","text":"batchstd(layer, x; wts = nothing, [mean])\n\nStandard deviation of x over batch dimensions, weigthed by wts.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.batchvar-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.batchvar","text":"batchvar(layer, x; wts = nothing, [mean])\n\nVariance of x over batch dimensions, weigthed by wts.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.block_matrix_invert-NTuple{4, AbstractMatrix}","page":"Reference","title":"RestrictedBoltzmannMachines.block_matrix_invert","text":"block_matrix_invert(A, B, C, D)\n\nInversion of a block matrix, using the formula:\n\nbeginbmatrix\n    mathbfA  mathbfB \n    mathbfC  mathbfD\nendbmatrix^-1\n=\nbeginbmatrix\n    left(mathbfA - mathbfB mathbfD^-1 mathbfCright)^-1  mathbf0 \n    mathbf0  left(mathbfD - mathbfC mathbfA^-1 mathbfBright)^-1\nendbmatrix\nbeginbmatrix\n    mathbfI  -mathbfB mathbfD^-1 \n    -mathbfC mathbfA^-1  mathbfI\nendbmatrix\n\nAssumes that A and D are square and invertible.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.block_matrix_logdet-NTuple{4, AbstractMatrix}","page":"Reference","title":"RestrictedBoltzmannMachines.block_matrix_logdet","text":"block_matrix_logdet(A, B, C, D)\n\nLog-determinant of a block matrix using the determinant lemma.\n\ndetleft(\n    beginbmatrix\n        mathbfA  mathbfB \n        mathbfC  mathbfD\n    endbmatrix\nright)\n= det(A) det(D - CA^-1B)\n= det(D) det(A - BD^-1C)\n\nHere we assume that A and D are invertible, and moreover are easy to invert (for example, if they are diagonal). We use this to chose one or the other of the two formulas above.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.broadlike-Tuple{Any, Vararg{Any}}","page":"Reference","title":"RestrictedBoltzmannMachines.broadlike","text":"broadlike(A, B...)\n\nBroadcasts A into the size of A .+ B .+ ... (without actually doing a sum).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.categorical_rand-Tuple{AbstractVector}","page":"Reference","title":"RestrictedBoltzmannMachines.categorical_rand","text":"categorical_rand(ps)\n\nRandomly draw i with probability ps[i]. You must ensure that ps defines a proper probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.categorical_sample-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.categorical_sample","text":"categorical_sample(P)\n\nGiven a probability array P of size (q, *), returns an array C of size (*), such that C[i] ∈ 1:q is a random sample from the categorical distribution P[:,i]. You must ensure that P defines a proper probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.categorical_sample_from_logits-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.categorical_sample_from_logits","text":"categorical_sample_from_logits(logits)\n\nGiven a logits array logits of size (q, *) (where q is the number of classes), returns an array X of size (*), such that X[i] is a categorical random sample from the distribution with logits logits[:,i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.categorical_sample_from_logits_gumbel-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.categorical_sample_from_logits_gumbel","text":"categorical_sample_from_logits_gumbel(logits)\n\nLike categoricalsamplefrom_logits, but using the Gumbel trick.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.cgf","page":"Reference","title":"RestrictedBoltzmannMachines.cgf","text":"cgf(layer, inputs = 0)\n\nCumulant generating function of layer, reduced over layer dimensions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.cold_metropolis-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.cold_metropolis","text":"cold_metropolis(rbm, v; steps = 1)\n\nSamples the rbm at zero temperature, starting from configuration v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.collect_states-Tuple{Union{RestrictedBoltzmannMachines.Binary, RestrictedBoltzmannMachines.Potts, RestrictedBoltzmannMachines.Spin}}","page":"Reference","title":"RestrictedBoltzmannMachines.collect_states","text":"collect_states(layer)\n\nReturns an array of all states of layer. Only defined for discrete layers.\n\nwarning: Warning\nUse only for small layers. For large layers, the exponential number of states will not fit in memory.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.colors-Tuple{Union{RestrictedBoltzmannMachines.Binary, RestrictedBoltzmannMachines.Spin}}","page":"Reference","title":"RestrictedBoltzmannMachines.colors","text":"colors(layer)\n\nNumber of possible states of units in discrete layers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.energies-Tuple{Union{RestrictedBoltzmannMachines.Binary, RestrictedBoltzmannMachines.Potts, RestrictedBoltzmannMachines.Spin}, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.energies","text":"energies(layer, x)\n\nEnergies of units in layer (not reduced over layer dimensions).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.energy-Tuple{Any, Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.energy","text":"energy(rbm, v, h)\n\nEnergy of the rbm in the configuration (v,h).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.energy-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.energy","text":"energy(layer, x)\n\nLayer energy, reduced over layer dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.flatten-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.flatten","text":"flatten(layer, x)\n\nReturns a vectorized version of x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.free_energy-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.free_energy","text":"free_energy(rbm, v)\n\nFree energy of visible configuration (after marginalizing hidden configurations).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.generate_sequences","page":"Reference","title":"RestrictedBoltzmannMachines.generate_sequences","text":"generate_sequences(n, A = 0:1)\n\nRetruns an iterator over all sequences of length n out of the alphabet A.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.initialize!","page":"Reference","title":"RestrictedBoltzmannMachines.initialize!","text":"initialize!(rbm, [data]; ϵ = 1e-6)\n\nInitializes the RBM and returns it. If provided, matches average visible unit activities from data.\n\ninitialize!(layer, [data]; ϵ = 1e-6)\n\nInitializes a layer and returns it. If provided, matches average unit activities from data.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.initialize_w!-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.initialize_w!","text":"initialize_w!(rbm, data; λ = 0.1)\n\nInitializes rbm.w such that typical inputs to hidden units are λ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.inputs_h_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.inputs_h_from_v","text":"inputs_h_from_v(rbm, v)\n\nInteraction inputs from visible to hidden layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.inputs_v_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.inputs_v_from_h","text":"inputs_v_from_h(rbm, h)\n\nInteraction inputs from hidden to visible layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.interaction_energy-Tuple{Any, Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.interaction_energy","text":"interaction_energy(rbm, v, h)\n\nWeight mediated interaction energy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_likelihood-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.log_likelihood","text":"log_likelihood(rbm, v)\n\nLog-likelihood of v under rbm, with the partition function compued by extensive enumeration. For discrete layers, this is exponentially slow for large machines.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_partition-Tuple{RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.log_partition","text":"log_partition(rbm)\n\nLog-partition of rbm, computed by extensive enumeration of visible states (except for particular cases such as Gaussian-Gaussian RBM). This is exponentially slow for large machines.\n\nIf your RBM has a smaller hidden layer, mirroring the layers of the rbm first (see mirror).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_partition_zero_weight-Tuple{Any}","page":"Reference","title":"RestrictedBoltzmannMachines.log_partition_zero_weight","text":"log_partition_zero_weight(rbm)\n\nLog-partition function of a zero-weight version of rbm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_pseudolikelihood-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.log_pseudolikelihood","text":"log_pseudolikelihood(rbm, v; exact = false)\n\nLog-pseudolikelihood of v. If exact is true, the exact pseudolikelihood is returned. But this is slow if v consists of many samples. Therefore by default exact is false, in which case the result is a stochastic approximation, where a random site is selected for each sample, and its conditional probability is calculated. In average the results with exact = false coincide with the deterministic result, and the estimate is more precise as the number of samples increases.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_pseudolikelihood_exact-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.log_pseudolikelihood_exact","text":"log_pseudolikelihood_exact(rbm, v)\n\nLog-pseudolikelihood of v. This function computes the exact pseudolikelihood, doing traces over all sites. Note that this can be slow for large number of samples.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_pseudolikelihood_sites-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray, AbstractArray{<:CartesianIndex}}","page":"Reference","title":"RestrictedBoltzmannMachines.log_pseudolikelihood_sites","text":"log_pseudolikelihood_sites(rbm, v, sites)\n\nLog-pseudolikelihood of a site conditioned on the other sites, where sites is an array of site indices (CartesianIndex), one for each sample. Returns an array of log-pseudolikelihood values, for each sample.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.log_pseudolikelihood_stoch-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.log_pseudolikelihood_stoch","text":"log_pseudolikelihood_stoch(rbm, v)\n\nLog-pseudolikelihood of v. This function computes an stochastic approximation, by doing a trace over random sites for each sample. For large number of samples, this is in average close to the exact value of the pseudolikelihood.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.logmeanexp-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.logmeanexp","text":"logmeanexp(A; dims=:)\n\nComputes log.(mean(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.logstdexp-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.logstdexp","text":"logstdexp(A; dims=:)\n\nComputes log.(std(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.logvarexp-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.logvarexp","text":"logvarexp(A; dims=:)\n\nComputes log.(var(exp.(A); dims)), in a numerically stable way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.mean_h_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.mean_h_from_v","text":"mean_h_from_v(rbm, v)\n\nMean unit activation values, conditioned on the other layer, <h | v>.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.mean_v_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.mean_v_from_h","text":"mean_v_from_h(rbm, v)\n\nMean unit activation values, conditioned on the other layer, <v | h>.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.metropolis!-Tuple{AbstractArray, RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.metropolis!","text":"metropolis!(v, rbm; β = 1)\n\nMetropolis-Hastings sampling from rbm at inverse temperature β. Uses v[:,:,..,:,1] as initial configurations, and writes the Monte-Carlo chains in v[:,:,..,:,2:end].\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.metropolis-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.metropolis","text":"metropolis(rbm, v; β = 1, steps = 1)\n\nMetropolis-Hastings sampling from rbm at inverse temperature β, starting from configuration v. Moves are proposed by normal Gibbs sampling.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.mirror-Tuple{Any}","page":"Reference","title":"RestrictedBoltzmannMachines.mirror","text":"mirror(rbm)\n\nReturns a new RBM with visible and hidden layers flipped.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.mode_h_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.mode_h_from_v","text":"mode_h_from_v(rbm, v)\n\nMode unit activations, conditioned on the other layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.mode_v_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.mode_v_from_h","text":"mode_v_from_h(rbm, h)\n\nMode unit activations, conditioned on the other layer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.moving_average-Tuple{AbstractArray, Int64}","page":"Reference","title":"RestrictedBoltzmannMachines.moving_average","text":"moving_average(A, m)\n\nMoving average of A with window size m.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.onehot_decode-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.onehot_decode","text":"onehot_decode(X)\n\nGiven a onehot encoded array X of N + 1 dimensions, returns the equivalent categorical array of N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.onehot_encode","page":"Reference","title":"RestrictedBoltzmannMachines.onehot_encode","text":"onehot_encode(A, code)\n\nGiven an array A of N dimensions, returns a one-hot encoded BitArray of N + 1 dimensions where single entries of the first dimension are one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.pcd!-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.pcd!","text":"pcd!(rbm, data)\n\nTrains the RBM on data using Persistent Contrastive divergence.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.raise-Tuple{RestrictedBoltzmannMachines.RBM, AbstractVector}","page":"Reference","title":"RestrictedBoltzmannMachines.raise","text":"raise(rbm::RBM, βs; v, init)\n\nReverse AIS estimator of the log-partition function of rbm. While aise tends to understimate the log of the partition function, raise tends to overstimate it. v must be an equilibrated sample from rbm.\n\n!!! tip Use logmeanexp     If F = raise(...), then -logmeanexp(-F), using the function logmeanexp[@ref]     provided in this package, tends to give a better approximation of log(Z) than mean(F).\n\n!!! tip Sandwiching the log-partition function     If Rf = aise(...), Rr = raise(...) are the AIS and reverse AIS estimators, we have the     stochastic bounds logmeanexp(Rf) ≤ log(Z) ≤ -logmeanexp(-Rr).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.randgumbel-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Reference","title":"RestrictedBoltzmannMachines.randgumbel","text":"randgumbel(T = Float64)\n\nGenerates a random Gumbel variate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.randnt-Tuple{Random.AbstractRNG, Real}","page":"Reference","title":"RestrictedBoltzmannMachines.randnt","text":"randnt([rng], a)\n\nRandom standard normal lower truncated at a (that is, Z ≥ a).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.randnt_half-Tuple{Random.AbstractRNG, Real, Real}","page":"Reference","title":"RestrictedBoltzmannMachines.randnt_half","text":"randnt_half([rng], μ, σ)\n\nSamples the normal distribution with mean μ and standard deviation σ truncated to positive values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.reconstruction_error-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.reconstruction_error","text":"reconstruction_error(rbm, v; steps = 1)\n\nStochastic reconstruction error of v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.rescale_activations!-Tuple{Union{RestrictedBoltzmannMachines.Binary, RestrictedBoltzmannMachines.Potts, RestrictedBoltzmannMachines.Spin}, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.rescale_activations!","text":"rescale_activations!(layer, λ::AbstractArray)\n\nFor continuous layers with scale parameters, re-parameterizes such that unit activations are divided by λ, and returns true. For other layers, does nothing and returns false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.rescale_hidden!-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.rescale_hidden!","text":"rescale_hidden!(rbm, λ::AbstractArray)\n\nFor continuous hidden units with a scale parameter, scales parameters such that hidden unit activations are divided by λ, and returns true. For other hidden units does nothing and returns false. The modified RBM is equivalent to the original one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.rescale_weights!-Tuple{RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.rescale_weights!","text":"rescale_weights!(rbm, λ::AbstractArray)\n\nFor continuous hidden units with a scale parameter, scales parameters such that the weights attached to each hidden unit have norm 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.reshape_maybe-Tuple{Number, Tuple{}}","page":"Reference","title":"RestrictedBoltzmannMachines.reshape_maybe","text":"reshape_maybe(x, shape)\n\nLike reshape(x, shape), except that zero-dimensional outputs are returned as scalars.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sample_h_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.sample_h_from_h","text":"sample_h_from_h(rbm, h; steps=1)\n\nSamples a hidden configuration conditional on another hidden configuration h. Ensures type stability by requiring that the returned array is of the same type as h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sample_h_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.sample_h_from_v","text":"sample_h_from_v(rbm, v)\n\nSamples a hidden configuration conditional on the visible configuration v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sample_v_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.sample_v_from_h","text":"sample_v_from_h(rbm, h)\n\nSamples a visible configuration conditional on the hidden configuration h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sample_v_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.sample_v_from_v","text":"sample_v_from_v(rbm, v; steps=1)\n\nSamples a visible configuration conditional on another visible configuration v. Ensures type stability by requiring that the returned array is of the same type as v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sitedims-Tuple{RestrictedBoltzmannMachines.AbstractLayer}","page":"Reference","title":"RestrictedBoltzmannMachines.sitedims","text":"sitedims(layer)\n\nNumber of dimensions of layer, with special handling of Potts layer, for which the first dimension doesn't count as a site dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sitesize-Tuple{RestrictedBoltzmannMachines.AbstractLayer}","page":"Reference","title":"RestrictedBoltzmannMachines.sitesize","text":"sitesize(layer)\n\nSize of layer, with special handling of Potts layer, for which the first dimension doesn't count as a site dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.sqrt1half-Tuple{Real}","page":"Reference","title":"RestrictedBoltzmannMachines.sqrt1half","text":"sqrt1half(x)\n\nAccurate computation of sqrt(1 + (x/2)^2) + |x|/2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.substitution_matrix_exhaustive","page":"Reference","title":"RestrictedBoltzmannMachines.substitution_matrix_exhaustive","text":"substitution_matrix_exhaustive(rbm, v)\n\nReturns an q x N x B tensor of free energies F, where q is the number of possible values of each site, B the number of data points, and N the sequence length:\n\n`q, N, B = size(v)\n\nThus F and v have the same size. The entry F[x,i,b] gives the free energy cost of flipping site i to x of v[b] from its original value to x, that is:\n\nF[x,i,b] = free_energy(rbm, v_) - free_energy(rbm, v[b])\n\nwhere v_ is the same as v[b] in all sites but i, where v_ has the value x.\n\nNote that i can be a set of indices.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.substitution_matrix_sites","page":"Reference","title":"RestrictedBoltzmannMachines.substitution_matrix_sites","text":"substitution_matrix_sites(rbm, v, sites)\n\nReturns an q x B matrix of free energies F, where q is the number of possible values of each site, and B the number of data points. The entry F[x,b] equals the free energy cost of flipping site[b] of v[b] to x, that is (schemetically):\n\nF[x, b] = free_energy(rbm, v_) - free_energy(rbm, v)\n\nwhere v = v[b], and v_ is the same as v in all sites except site[b], where v_ has the value x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.tnmean-Tuple{Real}","page":"Reference","title":"RestrictedBoltzmannMachines.tnmean","text":"tnmean(a)\n\nMean of the standard normal distribution, truncated to the interval (a, +∞).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.tnmeanvar-Tuple{Real}","page":"Reference","title":"RestrictedBoltzmannMachines.tnmeanvar","text":"tnmeanvar(a)\n\nMean and variance of the standard normal distribution truncated to the interval (a, +∞). Equivalent to tnmean(a), tnvar(a) but saves some common computations. WARNING: tnvar(a) can fail for very very large values ofa`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.tnvar-Tuple{Real}","page":"Reference","title":"RestrictedBoltzmannMachines.tnvar","text":"tnvar(a)\n\nVariance of the standard normal distribution, truncated to the interval (a, +∞). WARNING: Fails for very very large values of a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.total_mean_from_inputs","page":"Reference","title":"RestrictedBoltzmannMachines.total_mean_from_inputs","text":"total_mean_from_inputs(layer, inputs; wts = nothing)\n\nTotal mean of unit activations from inputs.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.total_meanvar_from_inputs","page":"Reference","title":"RestrictedBoltzmannMachines.total_meanvar_from_inputs","text":"total_meanvar_from_inputs(layer, inputs; wts = nothing)\n\nTotal mean and total variance of unit activations from inputs.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.total_var_from_inputs","page":"Reference","title":"RestrictedBoltzmannMachines.total_var_from_inputs","text":"total_var_from_inputs(layer, inputs; wts = nothing)\n\nTotal variance of unit activations from inputs.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.var_h_from_v-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.var_h_from_v","text":"var_h_from_v(rbm, v)\n\nVariance of unit activation values, conditioned on the other layer, var(h | v).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.var_v_from_h-Tuple{Any, Any}","page":"Reference","title":"RestrictedBoltzmannMachines.var_v_from_h","text":"var_v_from_h(rbm, v)\n\nVariance of unit activation values, conditioned on the other layer, var(v | h).\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.vstack-Tuple{Tuple}","page":"Reference","title":"RestrictedBoltzmannMachines.vstack","text":"vstack(x)\n\nStack arrays along a new dimension inserted on the left.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.vwiden-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.vwiden","text":"vwiden(x)\n\nAdds a singleton dimension on the left.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.wmean-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.wmean","text":"wmean(A; wts = nothing, dims = :)\n\nWeighted mean of A along dimensions dims, weighted by wts.\n\nfracsum_i A_i w_isum_i w_i\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.wsum-Tuple{AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.wsum","text":"wsum(A; wts = nothing, dims = :)\n\nWeighted sum of A along dimensions dims, weighted by wts.\n\nfracsum_i A_i w_i\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.zerosum!-Tuple{RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.zerosum!","text":"zerosum!(rbm)\n\nIn-place zero-sum gauge on rbm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.zerosum!-Tuple{RestrictedBoltzmannMachines.∂RBM, RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.zerosum!","text":"zerosum!(∂, rbm)\n\nProjects the gradient so that it doesn't modify the zerosum gauge.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.zerosum-Tuple{RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.zerosum","text":"zerosum(rbm)\n\nReturns an equivalent rbm in zerosum gauge. Only affects Potts layers. If the rbm doesn't have Potts layers, does nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.∂cgf","page":"Reference","title":"RestrictedBoltzmannMachines.∂cgf","text":"∂cgf(layer, inputs = 0; wts = 1)\n\nUnit activation moments, conjugate to layer parameters. These are obtained by differentiating cgfs with respect to the layer parameters. Averages over configurations (weigthed by wts).\n\n\n\n\n\n","category":"function"},{"location":"reference/#RestrictedBoltzmannMachines.∂energy-Tuple{RestrictedBoltzmannMachines.AbstractLayer, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.∂energy","text":"∂energy(layer, data; wts = nothing)\n\nDerivative of average energy of data with respect to layer parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.∂free_energy-Tuple{RestrictedBoltzmannMachines.RBM, AbstractArray}","page":"Reference","title":"RestrictedBoltzmannMachines.∂free_energy","text":"∂free_energy(rbm, v)\n\nGradient of free_energy(rbm, v) with respect to model parameters. If v consists of multiple samples (batches), then an average is taken.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RestrictedBoltzmannMachines.∂regularize!-Tuple{RestrictedBoltzmannMachines.∂RBM, RestrictedBoltzmannMachines.RBM}","page":"Reference","title":"RestrictedBoltzmannMachines.∂regularize!","text":"∂regularize!(∂, rbm; l2_fields = 0, l1_weights = 0, l2_weights = 0, l2l1_weights = 0)\n\nUpdates RBM gradients ∂, with the regularization gradient.\n\n\n\n\n\n","category":"method"},{"location":"#RestrictedBoltzmannMachines.jl-Documentation","page":"Home","title":"RestrictedBoltzmannMachines.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package to train and simulate Restricted Boltzmann Machines. The package is registered. Install it with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"RestrictedBoltzmannMachines\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The source code is hosted on Github.","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://github.com/cossio/RestrictedBoltzmannMachines.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package doesn't export any symbols. It can be imported like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import RestrictedBoltzmannMachines as RBMs","category":"page"},{"location":"","page":"Home","title":"Home","text":"to avoid typing a long name everytime.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the functions have a helpful docstring. See Reference section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the Examples listed on the menu on the left side bar to understand how the package works as a whole.","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/ais.jl\"","category":"page"},{"location":"literate/ais/#Annealed-importance-sampling","page":"AIS","title":"Annealed importance sampling","text":"","category":"section"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"We can compute the partition function of the RBM (and hence the log-likelihood) with annealed importance sampling (AIS).","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"import MLDatasets\nimport Makie\nimport CairoMakie\nimport RestrictedBoltzmannMachines as RBMs\nusing Statistics: mean, std, middle\nusing ValueHistories: MVHistory\nusing RestrictedBoltzmannMachines: Binary, BinaryRBM, initialize!, pcd!,\n    aise, raise, logmeanexp, logstdexp, sample_v_from_v","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Load MNIST (0 digit only).","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Float = Float32\ntrain_x, train_y = MLDatasets.MNIST.traindata()\ntrain_x = Array{Float}(train_x[:, :, train_y .== 0] .> 0.5)\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Train an RBM","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"rbm = BinaryRBM(Float, (28,28), 128)\ninitialize!(rbm, train_x)\n@time pcd!(rbm, train_x; iters=10000, batchsize=128)\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Get some equilibrated samples from model","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"v = train_x[:, :, rand(1:size(train_x, 3), 1000)]\nv = sample_v_from_v(rbm, v; steps=1000)\nnothing #hide","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Estimate Z with AIS and reverse AIS.","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"nsamples=100\nndists = [10, 100, 1000, 10_000, 100_000]\nR_ais = Vector{Float64}[]\nR_rev = Vector{Float64}[]\ninit = initialize!(Binary(; θ = zero(rbm.visible.θ)), v)\nnothing #hide\n\nfor nbetas in ndists\n    push!(R_ais,\n        @time aise(rbm; nbetas, nsamples, init)\n    )\n    push!(R_rev,\n        @time raise(rbm; nbetas, init, v=v[:,:,rand(1:size(v, 3), nsamples)])\n    )\nend","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"Plots","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"fig = Makie.Figure()\nax = Makie.Axis(\n    fig[1,1], width=700, height=400, xscale=log10, xlabel=\"interpolating distributions\", ylabel=\"log(Z)\"\n)\nMakie.band!(\n    ax, ndists,\n    mean.(R_ais) - std.(R_ais),\n    mean.(R_ais) + std.(R_ais);\n    color=(:blue, 0.25)\n)\nMakie.band!(\n    ax, ndists,\n    mean.(R_rev) - std.(R_rev),\n    mean.(R_rev) + std.(R_rev);\n    color=(:black, 0.25)\n)\nMakie.lines!(ax, ndists, mean.(R_ais); color=:blue, label=\"AIS\")\nMakie.lines!(ax, ndists, mean.(R_rev); color=:black, label=\"reverse AIS\")\nMakie.lines!(ax, ndists, logmeanexp.(R_ais); color=:blue, linestyle=:dash)\nMakie.lines!(ax, ndists, logmeanexp.(R_rev); color=:black, linestyle=:dash)\nMakie.lines!(ax, ndists, -logmeanexp.(-R_rev); color=:orange, linestyle=:dash)\nMakie.hlines!(ax, middle(mean(R_ais[end]), mean(R_rev[end])), linestyle=:dash, color=:red, label=\"limiting estimate\")\nMakie.xlims!(extrema(ndists)...)\nMakie.axislegend(ax, position=:rb)\nMakie.resize_to_layout!(fig)\nfig","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"","category":"page"},{"location":"literate/ais/","page":"AIS","title":"AIS","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"EditURL = \"https://github.com/cossio/RestrictedBoltzmannMachines.jl/blob/master/docs/src/literate/layers/ReLU.jl\"","category":"page"},{"location":"literate/layers/ReLU/#ReLU-layer","page":"ReLU","title":"ReLU layer","text":"","category":"section"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"In this example we look at what the ReLU layer hidden units look like, for different parameter values.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"First load some packages.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"import RestrictedBoltzmannMachines as RBMs\nusing CairoMakie, Statistics\nnothing #hide","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"Now initialize our ReLU layer, with unit parameters spanning an interesting range.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"θs = [0; 10]\nγs = [5; 10]\nlayer = RBMs.ReLU(; θ = [θ for θ in θs, γ in γs], γ = [γ for θ in θs, γ in γs])\nnothing #hide","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"Now we sample our layer to collect some data.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"data = RBMs.sample_from_inputs(layer, zeros(size(layer)..., 10^6))\nnothing #hide","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"Let's plot the resulting histogram of the activations of each unit. We also overlay the analytical PDF.","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"fig = Figure(resolution=(700,500))\nax = Axis(fig[1,1])\nxs = repeat(reshape(range(minimum(data), maximum(data), 100), 1, 1, 100), size(layer)...)\nps = exp.(-RBMs.cgfs(layer) .- RBMs.energies(layer, xs))\nfor (iθ, θ) in enumerate(θs), (iγ, γ) in enumerate(γs)\n    hist!(ax, data[iθ, iγ, :], normalization=:pdf, label=\"θ=$θ, γ=$γ\")\n    lines!(xs[iθ, iγ, :], ps[iθ, iγ, :], linewidth=2)\nend\naxislegend(ax)\nfig","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"","category":"page"},{"location":"literate/layers/ReLU/","page":"ReLU","title":"ReLU","text":"This page was generated using Literate.jl.","category":"page"}]
}
